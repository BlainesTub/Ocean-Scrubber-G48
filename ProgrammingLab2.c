#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           imeLeft,       tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port9,           motorRight,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          imeRight,      tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	3

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
	}
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		MOTOR_STOP = 0,
		MOTOR_RUNNING
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = MOTOR_STOP;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			// Code for MOTOR_STOP state:
		case MOTOR_STOP:
			// Turn motor off.
			motor[imeLeft] = 0;
			if ( button1_pushed ) {
				// If button1 pushed, change to the MOTOR_RUNNING state.
				exercise1_state = MOTOR_RUNNING;
				// Clear flag to indicate button 1 processed.
				button1_pushed = false;
			}
			break;
		case MOTOR_RUNNING:
			// Turn motor on.
			motor[imeLeft] = 50;
			if (button2_pushed) {
				// If button 2 pushed, transition to MOTOR_STOP state.
				exercise1_state = MOTOR_STOP;
				// Clear flag to indicate that button 2 processed.
				button2_pushed = false;
			}
			break;
		default:
		}

	}//end while
}

void exercise_2()
{
	enum T_test_state {
		state1 = 0,
		state2,
		state3
	};

	T_test_state test_state = state1;

	while(true)
	{
		monitorInput();

		/* INSERT CODE HERE
		* - Make sure EXERCISE_NUMBER is set to 2
		*/
		switch(test_state){

		case state1: //state1 is the stopped state

			resetMotorEncoder(imeLeft); //We reset the motor to 0 so when it goes to different states it
																 //measures it's position from this point.
			motor[imeLeft] = 0;         // Set the speed to 0.
			if(button1_pushed == true){// If button 1 is pushed
				test_state = state2;			 // it goes into state2 which is forward
				button1_pushed = false;  // say button 1 is no longer

			}
			break;

		case state2:
																 // state2 is forward
			motor[imeLeft] = 50;        // set the speed of the motor to 50
			if(getMotorEncoder(imeLeft) >= 627){  //if the position is more than 627 ( one rotation )
																					 //then set the state to state1 (stopped)

				test_state = state1;

			}
			if(button1_pushed == true){
				button1_pushed = false;    //if button1 is pushed while its moving, we don't want it to do anything so
																	 // we just say button 1 isnt pushed
			}
			break;


		}


	}// end while

} // end exercise_2

void exercise_3()
{
	enum T_test_state{          //Initialize 3 states
		stopped = 0,
		forward,
		backward,
	};
	T_test_state exer3_state = stopped;     //Set initial state to "stopped"
	while(true)
	{
		monitorInput();


		/* INSERT CODE HERE
		* - make sure EXERCISE_NUMBER is set to 3
		*/

		switch(exer3_state){

		case stopped:                            //Stopped Case
			writeDebugStream("Stopped");
			motor[imeLeft] = 0;										//Set motor speed to 50
			motor[imeRight] = 0;
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
			resetMotorEncoder(imeRight);             //Zero the motor encoder
			if(button1_pushed == true){
				exer3_state = forward;               //Change state to forward when button 1 pushed
				button1_pushed = false;              //debounce button1
			}
			if(button2_pushed == true){
				exer3_state = backward;             //Change state fo backwards when button 2 pushed
				button2_pushed = false;							//debounce button2
			}

			break;

		case forward:
		int motorpos = getMotorEncoder(imeRight);
			writeDebugStream("Forwards, (%d)", motorpos);
			int speed = 30;
			motor[imeLeft] = speed;										//Set motor speed to 50
			motor[imeRight] = speed;
			motor[motorLeft] = speed;
			motor[motorRight] = speed;
			if(button1_pushed == true){
				button1_pushed = false;             //If button 1 is pushed again, disregard
			}

			if(getMotorEncoder(imeRight) <= -3000){      //When the motor position <= 3000

				if(button2_pushed == true){
					exer3_state = backward;               //When forwards motion is complete, go backwards
					button2_pushed = false;               //Debounce button 2
					}else{
						exer3_state = stopped;              //If no other input, set state to stopped

						button1_pushed = false;             //Debounce button1
				}

				resetMotorEncoder(imeRight);
			}
			button1_pushed = false;
			break;

			case backward:


			motor[imeLeft] = -speed;										//Set motor speed to 50
			motor[imeRight] = speed;
			motor[motorLeft] = -speed;
			motor[motorRight] = speed;                      //Spin motor backwards
			if(button2_pushed == true){
				button2_pushed = false;                 //If button 2 is pushed again, disregard
			}

			if(getMotorEncoder(imeRight) <= -3000){     //Spin until motor position is -3000
				if(button1_pushed == true){
					exer3_state = forward;                //When backwards motion complete, go forwards
					button1_pushed = false;               //Debounce button 1
				}else{
					exer3_state = stopped;                //If no other input, set state to stop
				}
				resetMotorEncoder(imeRight);
			}
			button2_pushed = false;                   //Debounce button2
			break;

		}

	}//end while

}//end exercse_3


task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
	{
	case 1:
		exercise_1();
		break;
	case 2:
		exercise_2();
		break;
	case 3:
		exercise_3();
		break;
	default: //should never get here.
	} // end switch

}// end main
